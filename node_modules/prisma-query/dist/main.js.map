{"mappings":"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","sources":["src/index.ts","src/utils/processQueryUtils.ts","src/utils/generalUtils.ts"],"sourcesContent":["export type { QueryModifier } from 'types/generalTypes';\n\nexport {\n  processFindManyQuery,\n  processFindUniqueQuery,\n} from 'utils/processQueryUtils';\n","import { mergeObjects } from './generalUtils';\n\nconst splitByCommaIfString = (str: string | string[]) => {\n  if (Array.isArray(str)) return str;\n  return str.split(',');\n};\nconst supportCommaSeparatedStringIfPresent = (q: QueryValue) => {\n  const array: string[] = [];\n  if (Array.isArray(q)) {\n    q.forEach((v) => {\n      array.push(...splitByCommaIfString(v));\n    });\n  } else {\n    array.push(...splitByCommaIfString(q));\n  }\n  return array;\n};\n\nexport const processExpandString = (str: string): any => {\n  const dotFirstIndex = str.indexOf('.');\n  if (dotFirstIndex === -1) {\n    return {\n      include: {\n        [str]: true,\n      },\n    };\n  }\n  const beforeDot = str.slice(0, dotFirstIndex);\n  const afterDot = str.slice(dotFirstIndex + 1, str.length);\n  return {\n    include: {\n      [beforeDot]: processExpandString(afterDot),\n    },\n  };\n};\n\nexport const processRelationships = (\n  _embed?: QueryValue,\n  _expand?: QueryValue\n) => {\n  if (!_embed && !_expand) return;\n  const array: string[] = [];\n  if (_embed) {\n    array.push(...supportCommaSeparatedStringIfPresent(_embed));\n  }\n  if (_expand) {\n    array.push(...supportCommaSeparatedStringIfPresent(_expand));\n  }\n  let include: Record<string, any> = {};\n  for (let v of array) {\n    include = mergeObjects(include, processExpandString(v).include);\n  }\n  return include;\n};\nconst processSorting = (_sort?: string, _order?: string) => {\n  if (!_sort) return;\n  const sortArray = splitByCommaIfString(_sort);\n  const orderArray = (_order ? splitByCommaIfString(_order) : []) as (\n    | 'asc'\n    | 'desc'\n  )[];\n  const orderBy: Record<string, 'asc' | 'desc'>[] = [];\n  for (let i = 0; i < sortArray.length; i++) {\n    if (i < orderArray.length) {\n      orderBy.push({\n        [sortArray[i]]: orderArray[i],\n      });\n    } else {\n      orderBy.push({\n        [sortArray[i]]: 'asc',\n      });\n    }\n  }\n  return orderBy;\n};\n\ntype QueryValue = string | string[];\ntype Operator = 'gte' | 'lte' | 'gt' | 'lt' | 'ne' | 'like';\nconst operators: Operator[] = ['gte', 'lte', 'gt', 'lt', 'ne', 'like'];\n\nconst processOperators = (\n  operator: Operator,\n  value: string | number | boolean | null\n) => {\n  switch (operator) {\n    case 'gte': {\n      return {\n        gte: value,\n      };\n    }\n    case 'lte': {\n      return {\n        lte: value,\n      };\n    }\n    case 'gt': {\n      return {\n        gt: value,\n      };\n    }\n    case 'lt': {\n      return {\n        lt: value,\n      };\n    }\n    case 'ne': {\n      return {\n        not: value,\n      };\n    }\n    case 'like': {\n      if (typeof value === 'number' || typeof value === 'boolean') {\n        throw new Error(\"number/boolean value doesn't supports like operator\");\n      }\n      if (value === null) {\n        // passing value as null with like operator treats it as string\n        value = 'null';\n      }\n      if (value.startsWith('^')) {\n        return {\n          startsWith: value.slice(1),\n          mode: 'insensitive',\n        };\n      } else if (value.endsWith('$')) {\n        return {\n          endsWith: value.slice(0, value.length - 1),\n          mode: 'insensitive',\n        };\n      } else {\n        return {\n          contains: value,\n          mode: 'insensitive',\n        };\n      }\n    }\n  }\n};\nexport const regExpForParsingSpecialValues = {\n  bool: /^bool\\((true|false)\\)$/,\n  num: /^num\\(\\d+\\)$/,\n};\n\n/**\n *\n * @param value string\n * @returns string\n *\n * @example\n * getValueBetweenBrackets('num(12)')\n * return '12'\n *\n * getValueBetweenBrackets('bool(true)')\n * return 'true'\n */\nconst getValueBetweenBrackets = (value: string) => {\n  return value.slice(value.indexOf('(') + 1, value.length - 1);\n};\n\nexport const parseValue = ({\n  key,\n  value,\n  queryModifier,\n}: {\n  key: string;\n  value: string;\n  queryModifier?: TQueryModifier;\n}) => {\n  if (value === 'null') {\n    return null;\n  } else if (queryModifier?.numericValues?.includes(key)) {\n    return Number(value);\n  } else if (queryModifier?.booleanValues?.includes(key)) {\n    if (value === 'true') {\n      return true;\n    } else if (value === 'false') {\n      return false;\n    }\n  }\n  for (const [_type, regExp] of Object.entries(regExpForParsingSpecialValues)) {\n    const type = _type as keyof typeof regExpForParsingSpecialValues;\n    if (regExp.test(value)) {\n      switch (type) {\n        case 'bool': {\n          const val = getValueBetweenBrackets(value);\n          if (val === 'true') return true;\n          return false;\n        }\n        case 'num': {\n          const val = getValueBetweenBrackets(value);\n          return Number(val);\n        }\n      }\n    }\n  }\n  return value;\n};\nexport const supportNestedKey = (key: string, nestedKeyValue: any): any => {\n  const dotIndex = key.indexOf('.');\n  if (dotIndex === -1) {\n    return {\n      [key]: nestedKeyValue,\n    };\n  } else {\n    const firstKey = key.slice(0, dotIndex);\n    return {\n      [firstKey]: supportNestedKey(\n        key.slice(dotIndex + 1, key.length),\n        nestedKeyValue\n      ),\n    };\n  }\n};\nexport const transformDotKeysIntoNestedKeys = (where: Record<string, any>) => {\n  let updatedWhere: Record<string, any> = {};\n  for (const key in where) {\n    updatedWhere = mergeObjects(\n      updatedWhere,\n      supportNestedKey(key, where[key])\n    );\n  }\n  return updatedWhere;\n};\n\nexport const processFiltering = (\n  filters: Record<string, QueryValue>,\n  queryModifier?: TQueryModifier\n) => {\n  const where: Record<string, any> = {};\n  for (let key in filters) {\n    const value = filters[key];\n    if (Array.isArray(value)) {\n      where[key] = {\n        in: value.map((v) =>\n          parseValue({\n            key: key,\n            value: v,\n            queryModifier,\n          })\n        ),\n      };\n    } else {\n      const [rawKey, operator] = key.split('_');\n      const modifiedValue = parseValue({\n        key: rawKey,\n        value: value,\n        queryModifier: queryModifier,\n      });\n      if (operators.includes(operator as any)) {\n        if (where[rawKey]) {\n          where[rawKey] = {\n            ...where[rawKey],\n            ...processOperators(operator as Operator, modifiedValue),\n          };\n        } else {\n          where[rawKey] = processOperators(operator as Operator, modifiedValue);\n        }\n      } else {\n        where[rawKey] = modifiedValue;\n      }\n    }\n  }\n  return transformDotKeysIntoNestedKeys(where);\n};\nconst processPagination = (_page: number, _limit: number) => {\n  return {\n    take: _limit,\n    skip: (_page - 1) * _limit,\n  };\n};\nconst processSlicing = (_start: number, _end: number) => {\n  return {\n    take: _end - _start,\n    skip: _start,\n  };\n};\n\nconst getPrefixIndex = (arr: string[], key: string) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].startsWith(key + '.')) return i;\n  }\n  return -1;\n};\n\nexport const propogateWhereFiltersToNestedModels = ({\n  where,\n  include,\n  query,\n}: {\n  where: any;\n  include: any;\n  query: Record<string, QueryValue>;\n}) => {\n  const queryKeys = Object.keys(query);\n  const _expandIndex = queryKeys.indexOf('_expand');\n  const _embedIndex = queryKeys.indexOf('_embed');\n  for (let key in include) {\n    if (key in where) {\n      // below logic ensures that filter is not propogated if filter is before _expand/_embed\n      const prefixIndex = getPrefixIndex(queryKeys, key);\n      if (\n        _expandIndex !== -1 &&\n        prefixIndex !== -1 &&\n        prefixIndex < _expandIndex\n      ) {\n        continue;\n      }\n      if (\n        _embedIndex !== -1 &&\n        prefixIndex !== -1 &&\n        prefixIndex < _embedIndex\n      ) {\n        continue;\n      }\n\n      if (include[key] instanceof Object) {\n        include[key] = { ...include[key], where: where[key] };\n      } else {\n        include[key] = {\n          where: where[key],\n        };\n      }\n      delete where[key];\n    }\n  }\n};\nexport type TQueryModifier = {\n  numericValues?: string[] | undefined;\n  booleanValues?: string[] | undefined;\n};\nexport const processFindManyQuery = (\n  query: any,\n  queryModifier?: TQueryModifier\n) => {\n  const {\n    _embed,\n    _expand,\n    _sort,\n    _order,\n    _page,\n    _start,\n    _end,\n    _limit,\n    ...filters\n  } = query as Record<string, QueryValue>;\n  let skip: number | undefined;\n  let take: number | undefined;\n  // by default _limit = 10\n  const limit = _limit ? Number(_limit) : 10;\n  if (_page) {\n    const result = processPagination(Number(_page), limit);\n    skip = result.skip;\n    take = result.take;\n  } else if (_start) {\n    const start = Number(_start);\n    const end = _end ? Number(_end) : start + limit;\n    const result = processSlicing(start, end);\n    skip = result.skip;\n    take = result.take;\n  }\n  let where: any = processFiltering(filters, queryModifier);\n  const include = processRelationships(_embed, _expand);\n  propogateWhereFiltersToNestedModels({ where, include, query });\n  if (Object.keys(where).length === 0) {\n    where = undefined;\n  }\n  const options = {\n    where: where,\n    include: include,\n    orderBy: processSorting(_sort as string, _order as string),\n    skip,\n    take,\n  };\n  return options;\n};\nexport const processFindUniqueQuery = (query: any) => {\n  const { _embed, _expand, ...nestedFilters } = query as Record<\n    string,\n    QueryValue\n  >;\n  let where: any = processFiltering(nestedFilters);\n  const include = processRelationships(_embed, _expand);\n  propogateWhereFiltersToNestedModels({ where, include, query });\n  if (Object.keys(where).length === 0) {\n    where = undefined;\n  }\n  const options = {\n    include: include,\n  };\n  return options;\n};\n","export const mergeObjects = (target: any, source: any) => {\n  const sourceCopyModifiedKeys: any = {};\n  if (source) {\n    for (const key of Object.keys(source)) {\n      if (\n        source[key] instanceof Object &&\n        !Array.isArray(source[key]) &&\n        key in target\n      ) {\n        sourceCopyModifiedKeys[key] = {\n          ...source[key],\n          ...mergeObjects(target[key], source[key]),\n        };\n      }\n    }\n  }\n\n  return {\n    ...target,\n    ...source,\n    ...sourceCopyModifiedKeys,\n  };\n};\n"],"names":[],"version":3,"file":"main.js.map"}